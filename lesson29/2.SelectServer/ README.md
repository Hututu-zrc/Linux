这段代码实现了一个基于select的网络服务器，其运行逻辑如下：

1、程序通过Loop()函数进入主循环，设置_isrunning为true。
2、在每次循环开始时，初始化一个空的读文件描述符集合rfds（通过FD_ZERO(&rfds)）。
3、然后遍历_sockfds数组（该数组存储了所有需要监听的文件描述符，包括监听socket和已建立连接的客户端socket）：
    跳过无效的文件描述符（值为gdefaultfd的描述符）
    将有效的文件描述符添加到rfds集合中（通过FD_SET）
    找出最大的文件描述符值，用于select调用

4、设置超时时间为5秒，调用select函数监听可读事件。
5、根据select的返回值处理不同情况：
    0：表示超时，无事件发生，输出"Event not ready"
    -1：表示发生错误，输出错误信息
    正数：表示有文件描述符就绪，调用Dispatcher函数处理

6、Dispatcher函数遍历所有文件描述符：
    如果是监听socket且在rfds中被标记为可读，则调用Accepter接受新连接
    如果是客户端socket且在rfds中被标记为可读，则调用Recver处理数据接收

7、Accepter函数接受新连接：
    调用AcceptOrDie获取新的客户端连接
    在_sockfds数组中找一个空位置（值为gdefaultfd的位置）
    将新的文件描述符存入该位置
    注意：新连接的文件描述符不会立即添加到当前的rfds集合中，而是在下一次循环中才会被添加

8、Recver函数处理客户端数据：
    从指定的socket接收数据
    如果接收出错，关闭连接并将对应的_sockfds位置重置为gdefaultfd
    如果接收到0字节（客户端断开连接），关闭连接并重置_sockfds
    如果成功接收数据，进行处理（这里是简单回显）并发送响应

9、整个过程不断循环，持续监听和处理连接及数据。

关键点是新接受的连接不会在当前循环中被监听，而是要等到下一次循环重新构建rfds集合时才会被添加进去，这意味着新连接上的数据至少要等待一个循环周期后才能被处理。
Dispatcher函数：
    这里相当于每次有新的连接，等到下个循环才会开始使用
    select不停的接收新的连接，然后存到辅助数组里里面
    辅助数组里面的文件描述符越多，代表select控制的连接越多，有点相当于多线程的效果
    每次进入的Recver函数里面，就会遍历所有的文件描述符，然后接收消息，知道客户端关闭连接，此时才删除该文件描述符