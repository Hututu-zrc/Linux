
# EpollServer 类逻辑说明

`EpollServer` 类是一个使用 Linux `epoll` API 实现的 C++ TCP 服务器，用于高效处理事件驱动的 I/O 多路复用。它旨在同时管理多个客户端连接，通过监控文件描述符来处理事件，例如新连接到达或数据可读。以下是其核心组件和运行逻辑的详细说明。

## 概述
- **目的**: 创建一个 TCP 服务器，监听指定端口上的连接请求，并使用 `epoll` 机制处理客户端数据。
- **主要功能**:
  - 使用 `epoll` 实现非阻塞 I/O 处理。
  - 支持多个客户端同时连接。
  - 实现简单的回显服务器功能（接收客户端数据并返回）。
- **依赖**:
  - 依赖自定义的 `Socket` 模块（`Socket.hpp`）来管理 TCP 套接字操作。
  - 使用 Linux 系统调用（如 `epoll_create`、`epoll_ctl`、`epoll_wait` 等）。

## 类结构
`EpollServer` 类包含以下关键成员：
1. **端口**: 服务器监听的端口号，从字符串输入解析而来。
2. **套接字**: 一个指向 `TcpSocket` 对象的智能指针，用于管理监听套接字。
3. **运行标志**: 一个布尔值，表示服务器循环是否处于活动状态。
4. **Epoll 文件描述符**: 一个整数，表示 `epoll` 实例的文件描述符。
5. **事件数组**: 一个固定大小的数组，用于存储 `epoll_wait` 返回的事件。

## 初始化逻辑（`Init` 方法）
- **目的**: 配置服务器套接字并初始化 `epoll` 实例。
- **步骤**:
  1. **套接字设置**: 通过 `Socket` 模块的 `BulidTcpServerMethod` 创建一个绑定到指定端口的 TCP 服务器套接字。
  2. **创建 Epoll 实例**: 调用 `epoll_create` 初始化一个 `epoll` 实例，并提供预期文件描述符数量的提示（例如 256）。
     - 如果失败，记录错误日志并终止程序。
  3. **将监听套接字加入 Epoll**: 使用 `epoll_ctl` 和 `EPOLL_CTL_ADD` 操作将监听套接字的文件描述符注册到 `epoll` 实例中。
     - 设置事件为 `EPOLLIN`（表示监控读就绪，即新连接到达）。
     - 如果注册失败，记录错误并终止程序。
- **结果**: 服务器准备好接受连接，监听套接字已纳入 `epoll` 监控。

## 主事件循环（`Loop` 方法）
- **目的**: 持续运行服务器，等待并处理 I/O 事件。
- **步骤**:
  1. **设置超时**: 使用无限超时（-1），即阻塞等待事件发生。
  2. **事件等待**: 调用 `epoll_wait` 等待就绪事件，返回就绪的文件描述符数量。
  3. **事件处理**:
     - **超时情况（返回 0）**: 表示设置了超时但没有事件就绪，打印提示信息并短暂休眠。
     - **错误情况（返回 -1）**: 表示发生错误，打印错误信息。
     - **正常情况（返回大于 0）**: 调用分发函数处理就绪事件。
  4. **循环控制**: 只要运行标志为真，循环持续执行。
- **结果**: 服务器持续监听和处理事件，直到运行标志被置为假。

## 接受连接逻辑（`Accepter` 方法）
- **目的**: 处理新客户端连接。
- **步骤**:
  1. **接受连接**: 调用 `AcceptOrDie` 获取新客户端的文件描述符和地址信息（非阻塞操作）。
  2. **日志记录**: 打印新客户端的连接信息（文件描述符和 IP 地址）。
  3. **加入 Epoll**: 将新客户端的文件描述符添加到 `epoll` 实例中，监控 `EPOLLIN` 事件。
     - 如果添加失败，记录错误并终止。
- **结果**: 新客户端连接被接受并纳入 `epoll` 监控，准备处理后续数据。

## 数据接收逻辑（`Recver` 方法）
- **目的**: 处理客户端发送的数据。
- **步骤**:
  1. **接收数据**: 使用 `recv` 从指定文件描述符读取数据到缓冲区。
  2. **错误处理**:
     - 如果读取失败（返回小于 0），从 `epoll` 中移除该文件描述符并关闭它。
     - 如果客户端断开连接（返回 0），同样移除并关闭文件描述符。
  3. **正常处理**:
     - 如果读取成功，将数据打印出来。
     - 构造回显消息（添加 "echo#" 前缀），并通过 `send` 发送回客户端。
- **结果**: 数据被接收并回显给客户端，文件描述符保持打开以支持持续通信。

## 事件分发逻辑（`Dispatcher` 方法）
- **目的**: 根据就绪事件类型分发任务。
- **步骤**:
  1. **遍历就绪事件**: 循环处理 `epoll_wait` 返回的每个事件。
  2. **事件分类**:
     - **监听套接字事件**: 如果就绪的文件描述符是监听套接字且事件为 `EPOLLIN`，调用 `Accepter` 处理新连接。
     - **客户端套接字事件**: 如果是其他文件描述符且事件为 `EPOLLIN`，调用 `Recver` 处理数据。
  3. **日志记录**: 在分发开始和结束时记录调试信息。
- **结果**: 就绪事件被正确分配到对应的处理逻辑。

## 析构逻辑（`~EpollServer` 方法）
- **目的**: 清理资源。
- **步骤**:
  1. 关闭监听套接字。
  2. 如果 `epoll` 文件描述符有效，关闭它。
- **结果**: 所有资源被安全释放。

---

## 总结
`EpollServer` 是一个基于 `epoll` 的高效 TCP 服务器实现。它通过初始化监听套接字和 `epoll` 实例，在主循环中等待事件，并根据事件类型分发任务（接受连接或处理数据）。其设计强调非阻塞 I/O 和多客户端支持，适合需要高并发处理的场景。理论上，它利用了 `epoll` 的边缘触发或水平触发特性（默认水平触发），比传统的 `select` 或 `poll` 更高效。